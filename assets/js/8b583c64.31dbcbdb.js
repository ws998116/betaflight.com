"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9765],{3905:(e,t,l)=>{l.d(t,{Zo:()=>s,kt:()=>N});var a=l(67294);function r(e,t,l){return t in e?Object.defineProperty(e,t,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[t]=l,e}function n(e,t){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),l.push.apply(l,a)}return l}function i(e){for(var t=1;t<arguments.length;t++){var l=null!=arguments[t]?arguments[t]:{};t%2?n(Object(l),!0).forEach((function(t){r(e,t,l[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):n(Object(l)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(l,t))}))}return e}function o(e,t){if(null==e)return{};var l,a,r=function(e,t){if(null==e)return{};var l,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)l=n[a],t.indexOf(l)>=0||(r[l]=e[l]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)l=n[a],t.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(r[l]=e[l])}return r}var u=a.createContext({}),p=function(e){var t=a.useContext(u),l=t;return e&&(l="function"==typeof e?e(t):i(i({},t),e)),l},s=function(e){var t=p(e.components);return a.createElement(u.Provider,{value:t},e.children)},m="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var l=e.components,r=e.mdxType,n=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=p(l),c=r,N=m["".concat(u,".").concat(c)]||m[c]||k[c]||n;return l?a.createElement(N,i(i({ref:t},s),{},{components:l})):a.createElement(N,i({ref:t},s))}));function N(e,t){var l=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=l.length,i=new Array(n);i[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<n;p++)i[p]=l[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,l)}c.displayName="MDXCreateElement"},45775:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>n,metadata:()=>o,toc:()=>p});var a=l(87462),r=(l(67294),l(3905));const n={},i="Debug Modes",o={unversionedId:"wiki/archive/Debug-Modes",id:"wiki/archive/Debug-Modes",title:"Debug Modes",description:"CLI INFORMATION COMMANDS",source:"@site/docs/wiki/archive/Debug-Modes.md",sourceDirName:"wiki/archive",slug:"/wiki/archive/Debug-Modes",permalink:"/docs/wiki/archive/Debug-Modes",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"wiki",previous:{title:"Dshot & BetaFlight 3.1",permalink:"/docs/wiki/archive/DSHOT-ESC-Protocol"},next:{title:"Deep Dive",permalink:"/docs/wiki/archive/Deep-Dive"}},u={},p=[{value:"CLI INFORMATION COMMANDS",id:"cli-information-commands",level:3},{value:"DEBUG MODES",id:"debug-modes-1",level:3},{value:"GYRO SIGNAL (https://youtu.be/A09sprstYqI)",id:"gyro-signal-httpsyoutubea09sprstyqi",level:2},{value:"FILTERS (https://youtu.be/__vyp60cU_8)",id:"filters-httpsyoutube__vyp60cu_8",level:3},{value:"PIDs",id:"pids",level:2},{value:"ESC and MOTORS",id:"esc-and-motors",level:2},{value:"LOOPTIME STABILITY",id:"looptime-stability",level:2},{value:"RC SMOOTHING (https://youtu.be/M50fKpvFjT8)",id:"rc-smoothing-httpsyoutubem50fkpvfjt8",level:3},{value:"FLIGHT DYNAMICS",id:"flight-dynamics",level:3},{value:"SENSOR FUSION GYRO BOARDS:",id:"sensor-fusion-gyro-boards",level:2},{value:"VTX",id:"vtx",level:2},{value:"RX",id:"rx",level:2},{value:"Debug List",id:"debug-list",level:3}],s={toc:p};function m(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},s,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"debug-modes"},"Debug Modes"),(0,r.kt)("h3",{id:"cli-information-commands"},"CLI INFORMATION COMMANDS"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"VERSION" - Shows the current firmware loaded and the last github code commit ','[ie: "(9f67a584b)"]'," for the specific build of the firmware.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"STATUS" - Shows various information about the quad setup such as ROM space available for firmware, gyro type, detected voltage, etc...')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"TASKS" - Shows the active tasks running and their CPU utilization. Make sure the "gyro/PID tasks rate/hz is running at the specified rate.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"DSHOT_TELEMETRY_INFO" - Shows the Dshot RPM bi-directional telemetry packet success for each ESC. (4.1+)')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"RC_SMOOTHING_INFO" - Shows the detected RX frame rate. This only works if the "Filter" RC signal smoothing type is selected in the Receiver tab, and both "Input Cutoff Type" and "Derivative Cutoff Type" are set to "auto". The radio and RX need to be connected and powered up for the detected frame rate data to be valid.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"get DEBUG_MODE" - Shows the current debug mode and all available debug modes.'))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"debug-modes-1"},"DEBUG MODES"),(0,r.kt)("h2",{id:"gyro-signal-httpsyoutubea09sprstyqi"},"GYRO SIGNAL (",(0,r.kt)("a",{parentName:"h2",href:"https://youtu.be/A09sprstYqI"},"https://youtu.be/A09sprstYqI"),")"),(0,r.kt)("p",null,"GYRO_RAW: (Raw gyro data without scaling or filtering)\nFor use in seeing the unscaled gyro signal into the firmware for use in stack overflow detection (ICM gyros)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"UN"),"scaled"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"UN"),"scaled"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"UN"),"scaled"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"GYRO_SCALED: (Gyro data converted to deg/s, before any flight controller filtering)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"scaled")," into deg/sec"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"scaled")," into deg/sec"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: gyro signal input to firmware ",(0,r.kt)("strong",{parentName:"li"},"scaled")," into deg/sec"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"GYRO_FILTERED: (SAME AS GYRO TRACES RECORDED BY DEFAULT)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: filtered gyro trace"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: filtered gyro trace"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: filtered gyro trace"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"GYRO_SAMPLE: ("),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Gyro data before down-sampling to PID loop rate"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Gyro data at PID loop rate"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Gyro data at PID loop rate after RPM filtering"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Gyro data at PID loop rate, after RPM and all static filters, but before Dynamic Notch filters")),(0,r.kt)("h3",{id:"filters-httpsyoutube__vyp60cu_8"},"FILTERS (",(0,r.kt)("a",{parentName:"h3",href:"https://youtu.be/__vyp60cU_8"},"https://youtu.be/__vyp60cU_8"),")"),(0,r.kt)("p",null,"D_LPF:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: unfiltered D"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: unfiltered D"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = roll: filtered, after DMin/Dmax modification, pre application of TPA"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = pitch: filtered, after DMin/Dmax modification, pre application of TPA")),(0,r.kt)("p",null,"DYN_LPF:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: raw gyro data (scaled)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = roll: notch center frequency"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = roll: lowpass filter cutoff frequency"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = roll: pre-dyn notch (post lowpass filters)gyro data")),(0,r.kt)("p",null,"FFT_FREQ:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = gyroDebugAxis: notch 1 center frequency"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = gyroDebugAxis: notch 2 center frequency"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = gyroDebugAxis: notch 3 center frequency"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = gyroDebugAxis: pre-dyn notch gyro data (post lowpass and RPM filter)")),(0,r.kt)("p",null,"FFT:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = gyroDebugAxis: pre-dyn notch gyro data (post lowpass and RPM filter)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = gyroDebugAxis: post-dyn notch gyro data"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = gyroDebugAxis: downsampled data used for FFT"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"FFT_TIME:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = currently active calculation step"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = duration of this step"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = ","[empty]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"RPM_FILTER:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = motor #1 RPM Notch center frequency (where peak motor noise is anticipated)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = motor #2 RPM Notch center frequency"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = motor #3 RPM Notch center frequency"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = motor #4 RPM Notch center frequency")),(0,r.kt)("h2",{id:"pids"},"PIDs"),(0,r.kt)("p",null,"D_MIN:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = gyro factor (percent, scaled by ",(0,r.kt)("inlineCode",{parentName:"li"},"d_min_gain"),")"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = setpoint factor (percent, scaled by ",(0,r.kt)("inlineCode",{parentName:"li"},"d_min_advance"),"). The larger of ",(0,r.kt)("em",{parentName:"li"},"gyro")," and ",(0,r.kt)("em",{parentName:"li"},"setpoint")," factors takes effect."),(0,r.kt)("li",{parentName:"ul"},"[2]"," = roll: active D-term gain"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = pitch: active D-term gain")),(0,r.kt)("p",null,"ITERM_RELAX: (",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/QfiGTG5LfCk"},"https://youtu.be/QfiGTG5LfCk"),")"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = highpass filter to detect large setpoint changes"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = relax factor (percent, only used in ",(0,r.kt)("inlineCode",{parentName:"li"},"SETPOINT")," mode)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = relaxed I-term Error"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = absolute control axis error ","[roll]")),(0,r.kt)("p",null,"ANTI_GRAVITY: I and P boost during rapid throttle changes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = simple I gain factor from high-pass throttle (","*"," 1000)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = final I gain factor (includes a delayed smoothed lowpass element (","*"," 1000)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = P gain factor (","*"," 1000) ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = P gain factor (","*"," 1000) ","[pitch]")),(0,r.kt)("p",null,"FEEDFORWARD_LIMIT (FF_LIMIT): Cuts back on Feedforward when sticks rapidly approach max rate"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Limit factor ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Limit factor ","[pitch]"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Limited feedforward ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Not used")),(0,r.kt)("p",null,"FEEDFORWARD (4.3):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Interpolated Setpoint ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Setpoint delta, smoothed ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Boost factor, smoothed ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = RC Command delta ","[roll]"," (us)")),(0,r.kt)("p",null,"FF_INTERPOLATED (4.2):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Setpoint Delta ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Setpoint Acceleration ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Setpoint Acceleration, clipped ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Duplicate Counter")),(0,r.kt)("p",null,"FF_INTERPOLATED (4.0):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Setpoint Delta Impl","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Boost Amount ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Boost Amount, clipped ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Clip Amount")),(0,r.kt)("h2",{id:"esc-and-motors"},"ESC and MOTORS"),(0,r.kt)("p",null,"DSHOT_RPM_TELEMETRY: RPM in Configurator 10.8, eRPM for <10.8 (where RPM = eRPM ","*"," motor_magnet_count)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = motor #1 RPM"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = motor #2 RPM"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = motor #3 RPM"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = motor #4 RPM")),(0,r.kt)("p",null,"DSHOT_RPM_ERRORS:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Motor #1: the per-motor invalid packet percentages in hundredths of a percent (so 123 is 1.23%)"),(0,r.kt)("li",{parentName:"ul"},"[1]",' = Motor #2: "'),(0,r.kt)("li",{parentName:"ul"},"[2]",' = Motor #3: "'),(0,r.kt)("li",{parentName:"ul"},"[3]",' = Motor #4: "')),(0,r.kt)("p",null,"DYN_IDLE (4.3):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Dyn Idle P ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Dyn Idle I ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Dyn Idle D ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = min RPM (lowest current motor rpm)")),(0,r.kt)("p",null,"DYN_IDLE (<4.3):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = motorRangeMinIncrease ","*"," 1000"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = targetRpsChangeRate (simple RPM error ","*"," idle_adjustment_speed)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = error (amount of error to fix)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = minRps (lowest current motor rpm, in revolutions per second ",(0,r.kt)("em",{parentName:"li"}," 10)\nSo, for example, a minRps value of 500 corresponds to 50.0 ")," 60 = 3000rpm")),(0,r.kt)("h2",{id:"looptime-stability"},"LOOPTIME STABILITY"),(0,r.kt)("p",null,"CYCLETIME:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = The time in microseconds since the PID task last ran"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = The current CPU load in percent"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = The time since the previous motor update (uS)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = The variance in the motor update interval vs. the target PID loop time (uS)\nnote: with 4.2.x restructuring of the gyro/PID loops ","[2]"," & ","[3]"," are pointless since the motor updates are part of the PID task now.")),(0,r.kt)("p",null,"PIDLOOP:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," The time the Gyro Task ran (Useless post BF 4.2.x)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," Time microseconds the PID calculations"),(0,r.kt)("li",{parentName:"ul"},"[2]"," Time in microseconds for mixer, servos, motor update, dshot telemetry stats"),(0,r.kt)("li",{parentName:"ul"},"[3]"," Time in microseconds the mag hold and blackbox processing logic")),(0,r.kt)("p",null,"SCHEDULER_DETERMINISM:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," - Gyro task start cycle time in 10th of a us"),(0,r.kt)("li",{parentName:"ul"},"[1]"," - ID of late task"),(0,r.kt)("li",{parentName:"ul"},"[2]"," - Amount task is late in 10th of a us"),(0,r.kt)("li",{parentName:"ul"},"[3]"," - Gyro lock skew in clock cycles")),(0,r.kt)("p",null,"TIMING_ACCURACY:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," - % CPU busy"),(0,r.kt)("li",{parentName:"ul"},"[1]"," - Tasks late in last second"),(0,r.kt)("li",{parentName:"ul"},"[2]"," - Total lateness in last second in 10ths us"),(0,r.kt)("li",{parentName:"ul"},"[3]"," - Total tasks run in last second")),(0,r.kt)("h3",{id:"rc-smoothing-httpsyoutubem50fkpvfjt8"},"RC SMOOTHING (",(0,r.kt)("a",{parentName:"h3",href:"https://youtu.be/M50fKpvFjT8"},"https://youtu.be/M50fKpvFjT8"),")"),(0,r.kt)("p",null,"RC_INTERPOLATION:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = raw un-smoothed rc channel data ","[roll]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = current RX frame rate"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = interpolation step count"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = rc setpoint ","[roll]")),(0,r.kt)("p",null,"RC_SMOOTHING:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = raw un-smoothed rc channel data"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = raw un-smoothed setpoint derivative"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = filtered setpoint derivative before applied to setpoint weight"),(0,r.kt)("li",{parentName:"ul"},"[3]",' = the current calculated average (shows the current "locked" rate used to set the filters)')),(0,r.kt)("p",null,"RC_SMOOTHING_RATE:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = log each RX frame interval (shows the delay from the previous frame in microsecond)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = log the training step count"),(0,r.kt)("li",{parentName:"ul"},"[2]",' = the current calculated average (shows the current "locked" rate used to set the filters)'),(0,r.kt)("li",{parentName:"ul"},"[3]"," = indicates whether guard time is active")),(0,r.kt)("h3",{id:"flight-dynamics"},"FLIGHT DYNAMICS"),(0,r.kt)("p",null,"AC_ERROR (Absolute Control Error):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: axis error ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: axis error ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: axis error ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[none]")),(0,r.kt)("p",null,"AC_CORRECTION (AC = Absolute Control):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: axis AC correction ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: axis AC correction ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: axis AC correction ","*"," 10"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[none]")),(0,r.kt)("p",null,"FF_THUMB (Absolute Control Correction):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll normal FF"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = roll FF after stick limit"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = FF after max deflection"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = projected max rate due to stick extrapolation")),(0,r.kt)("h2",{id:"sensor-fusion-gyro-boards"},"SENSOR FUSION GYRO BOARDS:"),(0,r.kt)("p",null,"DUAL_GYRO_RAW:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: RAW gyro #1 data (NOT scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: RAW gyro #1 data (NOT scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = roll: RAW gyro #2 data (NOT scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = pitch: RAW gyro #2 data (NOT scaled to Deg/sec)")),(0,r.kt)("p",null,"DUAL_GYRO_SCALED:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: RAW SCALED gyro #1 data (scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: RAW SCALED gyro #1 data (scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = roll: RAW SCALED gyro #2 data (scaled to Deg/sec)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = pitch: RAW SCALED gyro #2 data (scaled to Deg/sec)")),(0,r.kt)("p",null,"DUAL_GYRO_DIFF:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = roll: gyro #1 filter \u2013 gyro #2 filtered"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = pitch: gyro #1 filter \u2013 gyro #2 filtered"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = yaw: gyro #1 filter \u2013 gyro #2 filtered"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"DUAL_GYRO_COMBINED: (programmer useful only)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = ","[empty]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = roll: filtered gyro (same as \u201cgyro\u201d trace)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = pitch: filtered gyro (same as \u201cgyro\u201d trace)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("p",null,"DUAL_GYRO_COMBINED: (programmer useful only)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = ","[empty]"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = roll: filtered gyro (same as \u201cgyro\u201d trace)"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = pitch: filtered gyro (same as \u201cgyro\u201d trace)"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = ","[empty]")),(0,r.kt)("h2",{id:"vtx"},"VTX"),(0,r.kt)("p",null,"SMARTAUDIO:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = SmartAudio Version ","*"," 100 + Device Mode"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Device Channel"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Device Frequency"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Device Power")),(0,r.kt)("p",null,"TRAMP"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Status"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Reply Code"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Pit Mode"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Retry Count")),(0,r.kt)("h2",{id:"rx"},"RX"),(0,r.kt)("p",null,"SBUS (FrSky SBUS)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Frame flags"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = State Flags"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Frame Time"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = not used")),(0,r.kt)("p",null,"FPORT (FrSky FPORT)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Frame Interval"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Frame Errors"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Last Error"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Telemetry Interval")),(0,r.kt)("p",null,"GHST (Ghost)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = CRC Error Count"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = RSSI"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Link Quality"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Unknown Frame count")),(0,r.kt)("p",null,"CRSF_LINK_STATISTICS_UPLINK"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Uplink RSSI 1"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Uplink RSSI 2"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Uplink Link Quality"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = RF Mode")),(0,r.kt)("p",null,"CRSF_LINK_STATISTICS_UPLINK"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Uplink RSSI 1"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Uplink RSSI 2"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Uplink Link Quality"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = RF Mode")),(0,r.kt)("p",null,"CRSF_LINK_STATISTICS_PWR"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Antenna"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = SNR"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Tx Power"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = not used")),(0,r.kt)("p",null,"CRSF_LINK_STATISTICS_DOWN"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Downlink RSSI"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Downlink LQ"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Downlink SNR"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = not used")),(0,r.kt)("p",null,"RX_SFHSS_SPI (FrSky SPI software based Rx)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = Data State"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = Missing Frame"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = Offset Max"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = Offset Min")),(0,r.kt)("p",null,"RX_EXPRESSLRS_PHASELOCK (ExpressLRS software based PPL)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = rawOffsetUs: instantaneous phase offset measured by last timer tick"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = offsetUs: filtered offset value used in software PLL"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = frequencyOffsetTicks: frequency offset (in timer ticks) between ELRS transmitter and RX"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = phaseShiftUs: current instantaneous phase shift value that will applied next timer tick")),(0,r.kt)("p",null,"RX_EXPRESSLRS_SPI (ExpressLRS SPI RX)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"[0]"," = lostConnectionCounter: counts the number of times the connection has been lost since startup"),(0,r.kt)("li",{parentName:"ul"},"[1]"," = rssiFiltered: current low-pass filtered RSSI value reported from sx1280/sx127x"),(0,r.kt)("li",{parentName:"ul"},"[2]"," = snr: current SNR reported by sx1280/sx127s"),(0,r.kt)("li",{parentName:"ul"},"[3]"," = uplinkLQ: uplink link quality percentage")),(0,r.kt)("h3",{id:"debug-list"},"Debug List"),(0,r.kt)("p",null,"Not all debug options are available in some firmware builds.\n| DEBUG TYPE |\n| :--- |\n| DEBUG_CYCLETIME |\n| DEBUG_BATTERY |\n| DEBUG_GYRO |\n| DEBUG_GYRO_FILTERED |\n| DEBUG_ACCELEROMETER |\n| DEBUG_PIDLOOP |\n| DEBUG_GYRO_SCALED |\n| DEBUG_RC_INTERPOLATION |\n| DEBUG_ANGLERATE |\n| DEBUG_ESC_SENSOR |\n| DEBUG_SCHEDULER |\n| DEBUG_STACK |\n| DEBUG_ESC_SENSOR_RPM |\n| DEBUG_ESC_SENSOR_TMP |\n| DEBUG_ALTITUDE |\n| DEBUG_FFT |\n| DEBUG_FFT_TIME |\n| DEBUG_FFT_FREQ |\n| DEBUG_RX_FRSKY_SPI |\n| DEBUG_RX_SFHSS_SPI |\n| DEBUG_GYRO_RAW |\n| DEBUG_DUAL_GYRO_RAW |\n| DEBUG_DUAL_GYRO_COMBINED |\n| DEBUG_DUAL_GYRO_DIFF |\n| DEBUG_MAX7456_SIGNAL |\n| DEBUG_MAX7456_SPICLOCK |\n| DEBUG_SBUS |\n| DEBUG_FPORT |\n| DEBUG_RANGEFINDER |\n| DEBUG_RANGEFINDER_QUALITY |\n| DEBUG_LIDAR_TF |\n| DEBUG_ADC_INTERNAL |\n| DEBUG_RUNAWAY_TAKEOFF |\n| DEBUG_SDIO |\n| DEBUG_CURRENT_SENSOR |\n| DEBUG_USB |\n| DEBUG_SMARTAUDIO |\n| DEBUG_RTH |\n| DEBUG_ITERM_RELAX |\n| DEBUG_ACRO_TRAINER |\n| DEBUG_RC_SMOOTHING |\n| DEBUG_RX_SIGNAL_LOSS |\n| DEBUG_RC_SMOOTHING_RATE |\n| DEBUG_ANTI_GRAVITY |\n| DEBUG_DYN_LPF |\n| DEBUG_RX_SPEKTRUM_SPI |\n| DEBUG_DSHOT_RPM_TELEMETRY |\n| DEBUG_RPM_FILTER |\n| DEBUG_D_MIN |\n| DEBUG_AC_CORRECTION |\n| DEBUG_AC_ERROR |\n| DEBUG_DUAL_GYRO_SCALED |\n| DEBUG_DSHOT_RPM_ERRORS |\n| DEBUG_CRSF_LINK_STATISTICS_UPLINK |\n| DEBUG_CRSF_LINK_STATISTICS_PWR |\n| DEBUG_CRSF_LINK_STATISTICS_DOWN |\n| DEBUG_BARO |\n| DEBUG_GPS_RESCUE_THROTTLE_PID |\n| DEBUG_DYN_IDLE |\n| DEBUG_FF_LIMIT |\n| DEBUG_FF_INTERPOLATED |\n| DEBUG_BLACKBOX_OUTPUT |\n| DEBUG_GYRO_SAMPLE |\n| DEBUG_RX_TIMING |\n| DEBUG_D_LPF |\n| DEBUG_VTX_TRAMP |\n| DEBUG_GHST |\n| SCHEDULER_DETERMINISM |\n| TIMING_ACCURACY |\n| DEBUG_RX_EXPRESSLRS_SPI |\n| DEBUG_RX_EXPRESSLRS_PHASELOCK |"))}m.isMDXComponent=!0}}]);