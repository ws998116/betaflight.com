"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2121],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),d=c(n),h=s,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,o=new Array(i);o[0]=h;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a[d]="string"==typeof e?e:s,o[1]=a;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},83504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=n(87462),s=(n(67294),n(3905));const i={},o=void 0,a={unversionedId:"Archive/Single-wire-FlySky-(IBus)-telemetry",id:"Archive/Single-wire-FlySky-(IBus)-telemetry",title:"Single-wire-FlySky-(IBus)-telemetry",description:"It's now possible to combine the serial rx and ibus telemetry on the same fc uart on a single pin.",source:"@site/docs/Archive/Single-wire-FlySky-(IBus)-telemetry.md",sourceDirName:"Archive",slug:"/Archive/Single-wire-FlySky-(IBus)-telemetry",permalink:"/docs/Archive/Single-wire-FlySky-(IBus)-telemetry",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Single-Wire-Software-Serial",permalink:"/docs/Archive/Single-Wire-Software-Serial"},next:{title:"Soft Mounting and Noise Reduction",permalink:"/docs/Archive/Soft-Mounting-and-Noise-Reduction"}},l={},c=[{value:"Technical details:",id:"technical-details",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"It's now possible to combine the serial rx and ibus telemetry on the same fc uart on a single pin."),(0,s.kt)("p",null,"I'm combining the ibus ports of the FS-iA6B receiver with a diode and a resistor."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"+---------+\n| FS-iA6B |\n|         |\n| Ser RX  |---|<---\\       +------------+\n|         |        |       | FC         |\n| Sensor  |---[R]--*-------| Uart TX    |\n+---------+                +------------+\n")),(0,s.kt)("p",null,"R = 10Kohm, Diode 1N4148 or similar."),(0,s.kt)("p",null,"Note (2018-07-27): In some cases, the value of the series resistor may be too large, and going down to 1K","[ohm]"," may provide a good result."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://cloud.githubusercontent.com/assets/6065378/23835685/0ed7bfc6-076c-11e7-9c27-dcf6b9686847.png",alt:"image"})),(0,s.kt)("p",null,"Both uart tx and rx channels are used so it's not possible to use the spare pin for rx of something else."),(0,s.kt)("p",null,"Configure the serial port like this to get both serial rx and ibus telemetry on the same port:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"serial 1 4160 115200 57600 115200 115200\n")),(0,s.kt)("p",null,"It is still possible to run the serial rx and ibus telemetry on two uarts like before, an example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"serial 1 64 115200 57600 0 115200\nserial 2 4096 115200 57600 115200 115200\n")),(0,s.kt)("p",null,"This is how the signals look:\n",(0,s.kt)("img",{parentName:"p",src:"https://cloud.githubusercontent.com/assets/6065378/23835770/5dd5c9f0-076d-11e7-84eb-486759996cd2.png",alt:"image"})),(0,s.kt)("h2",{id:"technical-details"},"Technical details:"),(0,s.kt)("p",null,"Ibus Telemetry is a half-duplex serial protocol. It shares 1 line for\nboth TX and RX. It runs at a fixed baud rate of 115200. Queries are sent\nevery 7ms by the iBus receiver. Multiple sensors can be daisy chained with\nibus but this is implemented but not tested because i don't have one of the\nsensors to test with"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," _______\n/       \\                                             /---------\\\n| STM32 |--UART TX--\x3e[Bi-directional @ 115200 baud]<--| IBUS RX |\n|  uC   |--UART RX--x[not connected]                  \\---------/\n\\_______/\n")),(0,s.kt)("p",null,"The protocol is driven by the iBus receiver, currently either an IA6B or\nIA10. All iBus traffic is little endian. It begins with the iBus rx\nquerying for a sensor on the iBus:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"/---------\\\n| IBUS RX | > Hello sensor at address 1, are you there?\n\\---------/     [ 0x04, 0x81, 0x7A, 0xFF ]\n\n0x04       - Packet Length\n0x81       - bits 7-4 Command (1000 = discover sensor)\n             bits 3-0 Address (0001 = address 1)\n0x7A, 0xFF - Checksum, 0xFFFF - (0x04 + 0x81)\n")),(0,s.kt)("p",null,"Due to the daisy-chaining, this hello also serves to inform the sensor\nof its address (position in the chain). There are 16 possible addresses\nin iBus, however address 0 is reserved for the rx's internally measured\nvoltage leaving 0x1 to 0xF remaining."),(0,s.kt)("p",null,"Having learned it's address, the sensor simply echos the message back:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                                                 /--------\\\n                         Yes, i'm here, hello! < | Sensor |\n                  [ 0x04, 0x81, 0x7A, 0xFF ]     \\--------/\n\n0x04, 0x81, 0x7A, 0xFF - Echo back received packet\n")),(0,s.kt)("p",null,"On receipt of a response, the iBus rx next requests the sensor's type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"/---------\\\n| IBUS RX | > Sensor at address 1, what type are you?\n\\---------/     [ 0x04, 0x91, 0x6A, 0xFF ]\n\n0x04       - Packet Length\n0x91       - bits 7-4 Command (1001 = request sensor type)\n             bits 3-0 Address (0001 = address 1)\n0x6A, 0xFF - Checksum, 0xFFFF - (0x04 + 0x91)\n")),(0,s.kt)("p",null,"To which the sensor responds with its details:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"                                                 /--------\\\n                         Yes, i'm here, hello! < | Sensor |\n           [ 0x06 0x91 0x00 0x02 0x66 0xFF ]     \\--------/\n\n0x06       - Packet Length\n0x91       - bits 7-4 Command (1001 = request sensor type)\n             bits 3-0 Address (0001 = address 1)\n0x00       - Measurement type (0 = internal voltage)\n0x02       - Unknown, always 0x02\n0x66, 0xFF - Checksum, 0xFFFF - (0x06 + 0x91 + 0x00 + 0x02)\n")),(0,s.kt)("p",null,"The iBus rx continues the discovery process by querying the next\naddress. Discovery stops at the first address which does not respond."),(0,s.kt)("p",null,"The iBus rx then begins a continual loop, requesting measurements from\neach sensor discovered:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"/---------\\\n| IBUS RX | > Sensor at address 1, please send your measurement\n\\---------/     [ 0x04, 0xA1, 0x5A, 0xFF ]\n\n0x04       - Packet Length\n0xA1       - bits 7-4 Command (1010 = request measurement)\n             bits 3-0 Address (0001 = address 1)\n0x5A, 0xFF - Checksum, 0xFFFF - (0x04 + 0xA1)\n\n                                                 /--------\\\n                           I'm reading 0 volts < | Sensor |\n           [ 0x06 0xA1 0x00 0x00 0x5E 0xFF ]     \\--------/\n\n0x06       - Packet Length\n0xA1       - bits 7-4 Command (1010 = request measurement)\n             bits 3-0 Address (0001 = address 1)\n0x00, 0x00 - The measurement\n0x58, 0xFF - Checksum, 0xFFFF - (0x06 + 0xA1 + 0x00 + 0x00)\n")),(0,s.kt)("p",null,"Due to the limited telemetry data types possible with ibus, we\nsimply send everything which can be represented. Currently this\nis voltage and temperature and throttle value."))}d.isMDXComponent=!0}}]);