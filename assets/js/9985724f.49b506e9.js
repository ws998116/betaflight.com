"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6198],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>c});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=n.createContext({}),s=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},h=function(e){var t=s(e.components);return n.createElement(d.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,d=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),g=s(a),p=i,c=g["".concat(d,".").concat(p)]||g[p]||u[p]||r;return a?n.createElement(c,l(l({ref:t},h),{},{components:a})):n.createElement(c,l({ref:t},h))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=p;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[g]="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2335:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var n=a(87462),i=(a(67294),a(3905));const r={},l="Blackbox logging internals",o={unversionedId:"development/Blackbox Internals",id:"development/Blackbox Internals",title:"Blackbox logging internals",description:"The Blackbox is designed to record the raw internal state of the flight controller at near-maximum rate. By logging the",source:"@site/docs/development/Blackbox Internals.md",sourceDirName:"development",slug:"/development/Blackbox Internals",permalink:"/docs/development/Blackbox Internals",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Contributing to Betaflight",permalink:"/docs/development/Betaflight-Contribution"},next:{title:"Blackbox flight data recorder",permalink:"/docs/development/Blackbox"}},d={},s=[{value:"References",id:"references",level:2},{value:"Logging cycle",id:"logging-cycle",level:2},{value:"Log frame types",id:"log-frame-types",level:2},{value:"Main frames: I, P",id:"main-frames-i-p",level:3},{value:"GPS frames: G, H",id:"gps-frames-g-h",level:3},{value:"Slow frames: S",id:"slow-frames-s",level:3},{value:"Event frames: E",id:"event-frames-e",level:3},{value:"Log field format",id:"log-field-format",level:2},{value:"Field predictors",id:"field-predictors",level:3},{value:"Predict zero (0)",id:"predict-zero-0",level:4},{value:"Predict last value (1)",id:"predict-last-value-1",level:4},{value:"Predict straight line (2)",id:"predict-straight-line-2",level:4},{value:"Predict average 2 (3)",id:"predict-average-2-3",level:4},{value:"Predict minthrottle (4)",id:"predict-minthrottle-4",level:4},{value:"Predict motor0 (5)",id:"predict-motor0-5",level:4},{value:"Predict increment (6)",id:"predict-increment-6",level:4},{value:"Predict home-coord (7)",id:"predict-home-coord-7",level:4},{value:"Predict 1500 (8)",id:"predict-1500-8",level:4},{value:"Predict vbatref (9)",id:"predict-vbatref-9",level:4},{value:"Predict last main-frame time (10)",id:"predict-last-main-frame-time-10",level:4},{value:"Field encoders",id:"field-encoders",level:3},{value:"Unsigned variable byte (1)",id:"unsigned-variable-byte-1",level:4},{value:"Signed variable byte (0)",id:"signed-variable-byte-0",level:4},{value:"Neg 14-bit (3)",id:"neg-14-bit-3",level:4},{value:"Elias delta unsigned 32-bit (4)",id:"elias-delta-unsigned-32-bit-4",level:4},{value:"Elias delta signed 32-bit (5)",id:"elias-delta-signed-32-bit-5",level:4},{value:"TAG8_8SVB (6)",id:"tag8_8svb-6",level:4},{value:"TAG2_3S32 (7)",id:"tag2_3s32-7",level:4},{value:"TAG8_4S16 (8)",id:"tag8_4s16-8",level:4},{value:"NULL (9)",id:"null-9",level:4},{value:"Log file structure",id:"log-file-structure",level:2},{value:"Log start marker",id:"log-start-marker",level:3},{value:"Log header",id:"log-header",level:3},{value:"Data version (required)",id:"data-version-required",level:4},{value:"Logging interval",id:"logging-interval",level:4},{value:"I interval",id:"i-interval",level:5},{value:"P interval",id:"p-interval",level:5},{value:"Firmware type (optional)",id:"firmware-type-optional",level:4},{value:"Field X name (required)",id:"field-x-name-required",level:4},{value:"Field X signed (optional)",id:"field-x-signed-optional",level:4},{value:"Field X predictor (required)",id:"field-x-predictor-required",level:4},{value:"Field X encoding (required)",id:"field-x-encoding-required",level:4},{value:"vbatref",id:"vbatref",level:4},{value:"minthrottle",id:"minthrottle",level:4},{value:"Additional headers",id:"additional-headers",level:4},{value:"Log payload",id:"log-payload",level:3},{value:"Log end marker",id:"log-end-marker",level:3},{value:"Log validation",id:"log-validation",level:2}],h={toc:s};function g(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"blackbox-logging-internals"},"Blackbox logging internals"),(0,i.kt)("p",null,"The Blackbox is designed to record the raw internal state of the flight controller at near-maximum rate. By logging the\nraw inputs and outputs of key flight systems, the Blackbox log aims to allow the offline bench-top simulation, debugging,\nand testing of flight control algorithms using data collected from real flights."),(0,i.kt)("p",null,"A typical logging regime might capture 30 different state variables (for an average of 28 bytes per frame) at a sample\nrate of 900Hz. That's about 25,000 bytes per second, which is 250,000 baud with a typical 8-N-1 serial encoding."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("p",null,"Please refer to the source code to clarify anything this document leaves unclear:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Cleanflight's Blackbox logger: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/cleanflight/cleanflight/blob/master/src/main/blackbox/blackbox.c"},"blackbox.c"),",\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/cleanflight/cleanflight/blob/master/src/main/blackbox/blackbox_io.c"},"blackbox_io.c"),",\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/cleanflight/cleanflight/blob/master/src/main/blackbox/blackbox_fielddefs.h"},"blackbox_fielddefs.h")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cleanflight/blackbox-tools/blob/master/src/parser.c"},"C implementation of the Blackbox log decoder")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/cleanflight/blackbox-log-viewer/blob/master/js/flightlog_parser.js"},"JavaScript implementation of the Blackbox log decoder"))),(0,i.kt)("h2",{id:"logging-cycle"},"Logging cycle"),(0,i.kt)("p",null,'Blackbox is designed for flight controllers that are based around the concept of a "main loop". During each main loop\niteration, the flight controller will read some state from sensors, run some flight control algorithms, and produce some\noutputs. For each of these loop iterations, a Blackbox "logging iteration" will be executed. This will read data that\nwas stored during the execution of the main loop and log this data to an attached logging device. The data will include\nalgorithm inputs such as sensor and RC data, intermediate results from flight control algorithms, and algorithm outputs\nsuch as motor commands.'),(0,i.kt)("h2",{id:"log-frame-types"},"Log frame types"),(0,i.kt)("p",null,'Each event which is recorded to the log is packaged as a "log frame". Blackbox only uses a handful of different types of\nlog frames. Each frame type is identified by a single capital letter.'),(0,i.kt)("h3",{id:"main-frames-i-p"},"Main frames: I, P"),(0,i.kt)("p",null,'The most basic kind of logged frames are the "main frames". These record the primary state of the flight controller (RC\ninput, gyroscopes, flight control algorithm intermediates, motor outputs), and are logged during every logging\niteration.'),(0,i.kt)("p",null,'Each main frame must contain at least two fields, "loopIteration" which records the index of the current main loop\niteration (starting at zero for the first logged iteration), and "time" which records the timestamp of the beginning of\nthe main loop in microseconds (this needn\'t start at zero, on Cleanflight it represents the system uptime).'),(0,i.kt)("p",null,'There are two kinds of main frames, "I" and "P". "I", or "intra" frames are like video keyframes. They can be decoded\nwithout reference to any previous frame, so they allow log decoding to be resynchronized in the event of log damage. "P"\nor "inter" frames use an encoding which references previously logged frames in order to reduce the required datarate.\nWhen one interframe fails to decode, all following interframes will be undecodable up until the next intraframe.'),(0,i.kt)("h3",{id:"gps-frames-g-h"},"GPS frames: G, H"),(0,i.kt)("p",null,"Because the GPS is updated so infrequently, GPS data is logged in its own dedicated frames. These are recorded whenever\nthe GPS data changes (not necessarily alongside every main frame). Like the main frames, the GPS frames have their own\nintra/inter encoding system."),(0,i.kt)("p",null,'The "H" or "home" frame records the lat/lon of a reference point. The "G" or "GPS" frame records the current state of\nthe GPS system (current position, altitude etc.) based on the reference point. The reference point can be updated\n(infrequently) during the flight, and is logged whenever it changes.'),(0,i.kt)("p",null,'To allow "G" frames to continue be decoded in the event that an "H" update is dropped from the log, the "H" frame is\nlogged periodically even if it has not changed (say, every 10 seconds). This caps the duration of unreadble "G" frames\nthat will result from a single missed "H" change.'),(0,i.kt)("h3",{id:"slow-frames-s"},"Slow frames: S"),(0,i.kt)("p",null,'Some flight controller state is updated very infrequently (on the order of once or twice a minute). Logging the fact\nthat this data had not been updated during every single logging iteration would be a waste of bandwidth, so these frames\nare only logged when the "slow" state actually changes.'),(0,i.kt)("p",null,"All Slow frames are logged as intraframes. An interframe encoding scheme can't be used for Slow frames, because one\ndamaged frame causes all subsequent interframes to be undecodable. Because Slow frames are written so infrequently, one\nmissing Slow frame could invalidate minutes worth of Slow state."),(0,i.kt)("p",null,"On Cleanflight, Slow frames are currently used to log data like the user-chosen flight mode and the current failsafe\nstate."),(0,i.kt)("h3",{id:"event-frames-e"},"Event frames: E"),(0,i.kt)("p",null,'Some flight controller data is updated so infrequently or exists so transiently that we do not log it as a flight\ncontroller "state". Instead, we log it as a state ',(0,i.kt)("em",{parentName:"p"},"transition"),' . This data is logged in "E" or "event" frames. Each event\nframe payload begins with a single byte "event type" field. The format of the rest of the payload is not encoded in the\nflight log, so its interpretation is left up to an agreement of the writer and the decoder.'),(0,i.kt)("p",null,"For example, one event that Cleanflight logs is that the user has adjusted a system setting (such as a PID setting)\nusing Cleanflight's inflight adjustments feature. The event payload notes which setting was adjusted and the new value\nfor the setting."),(0,i.kt)("p",null,'Because these setting updates are so rare, it would be wasteful to treat the settings as "state" and log the fact that\nthe setting had not been changed during every logging iteration. It would be infeasible to periodically log the system\nsettings using an intra/interframe scheme, because the intraframes would be so large. Instead we only log the\ntransitions as events, accept the small probability that any one of those events will be damaged/absent in the log, and\nleave it up to log readers to decide the extent to which they are willing to assume that the state of the setting\nbetween successfully-decoded transition events was truly unchanged.'),(0,i.kt)("h2",{id:"log-field-format"},"Log field format"),(0,i.kt)("p",null,"For every field in a given frame type, there is an associated name, predictor, and encoding."),(0,i.kt)("p",null,"When a field is written, the chosen predictor is computed for the field, then this predictor value is subtracted from\nthe raw field value. Finally, the encoder is used to transform the value into bytes to be written to the logging device."),(0,i.kt)("h3",{id:"field-predictors"},"Field predictors"),(0,i.kt)("p",null,'The job of the predictor is to bring the value to be encoded as close to zero as possible. The predictor may be based\non the values seen for the field in a previous frame, or some other value such as a fixed value or a value recorded in\nthe log headers. For example, the battery voltage values in "I" intraframes in Cleanflight use a reference voltage that\nis logged as part of the headers as a predictor. This assumes that battery voltages will be broadly similar to the\ninitial pack voltage of the flight (e.g. 4S battery voltages are likely to lie within a small range for the whole\nflight). In "P" interframes, the battery voltage will instead use the previously-logged voltage as a predictor, because\nthe correlation between successive voltage readings is high.'),(0,i.kt)("p",null,"These predictors are presently available:"),(0,i.kt)("h4",{id:"predict-zero-0"},"Predict zero (0)"),(0,i.kt)("p",null,"This predictor is the null-predictor which doesn't modify the field value at all. It is a common choice for fields\nwhich are already close to zero, or where no better history is available (e.g. in intraframes which may not rely on the\nprevious value of fields)."),(0,i.kt)("h4",{id:"predict-last-value-1"},"Predict last value (1)"),(0,i.kt)("p",null,"This is the most common predictor in interframes. The last-logged value of the field will be used as the predictor, and\nsubtracted from the raw field value. For fields which don't change very often, this will make their encoded value be\nnormally zero. Most fields have some time-correlation, so this predictor should reduce the magnitude of all but the\nnoisiest fields."),(0,i.kt)("h4",{id:"predict-straight-line-2"},"Predict straight line (2)"),(0,i.kt)("p",null,'This predictor assumes that the slope between the current measurement and the previous one will be similar to the\nslope between the previous measurement and the one before that. This is common for fields which increase at a steady rate,\nsuch as the "time" field. The predictor is ',(0,i.kt)("inlineCode",{parentName:"p"},"history_age_2 - 2 * history_age_1"),"."),(0,i.kt)("h4",{id:"predict-average-2-3"},"Predict average 2 (3)"),(0,i.kt)("p",null,"This predictor is the average of the two previously logged values of the field (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"(history_age_1 + history_age_2) / 2"),"\n). It is used when there is significant random noise involved in the field, which means that the average of the recent\nhistory is a better predictor of the next value than the previous value on its own would be (for example, in gyroscope\nor motor measurements)."),(0,i.kt)("h4",{id:"predict-minthrottle-4"},"Predict minthrottle (4)"),(0,i.kt)("p",null,'This predictor subtracts the value of "minthrottle" which is included in the log header. In Cleanflight, motors always\nlie in the range of ',(0,i.kt)("inlineCode",{parentName:"p"},"[minthrottle ... maxthrottle]")," when the craft is armed, so this predictor is used for the first\nmotor value in intraframes."),(0,i.kt)("h4",{id:"predict-motor0-5"},"Predict motor","[0]"," (5)"),(0,i.kt)("p",null,"This predictor is set to the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"motor[0]")," which was decoded earlier within the current frame. It is used in\nintraframes for every motor after the first one, because the motor commands typically lie in a tight grouping."),(0,i.kt)("h4",{id:"predict-increment-6"},"Predict increment (6)"),(0,i.kt)("p",null,"This predictor assumes that the field will be incremented by 1 unit for every main loop iteration. This is used to\npredict the ",(0,i.kt)("inlineCode",{parentName:"p"},"loopIteration")," field, which increases by 1 for every loop iteration."),(0,i.kt)("h4",{id:"predict-home-coord-7"},"Predict home-coord (7)"),(0,i.kt)("p",null,'This predictor is set to the corresponding latitude or longitude field from the GPS home coordinate (which was logged in\na preceding "H" frame). If no preceding "H" frame exists, the value is marked as invalid.'),(0,i.kt)("h4",{id:"predict-1500-8"},"Predict 1500 (8)"),(0,i.kt)("p",null,"This predictor is set to a fixed value of 1500. It is preferred for logging servo values in intraframes, since these\ntypically lie close to the midpoint of 1500us."),(0,i.kt)("h4",{id:"predict-vbatref-9"},"Predict vbatref (9)"),(0,i.kt)("p",null,'This predictor is set to the "vbatref" field written in the log header. It is used when logging intraframe battery\nvoltages in Cleanflight, since these are expected to be broadly similar to the first battery voltage seen during\narming.'),(0,i.kt)("h4",{id:"predict-last-main-frame-time-10"},"Predict last main-frame time (10)"),(0,i.kt)("p",null,"This predictor is set to the last logged ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," field from the main frame. This is used when predicting timestamps of\nnon-main frames (e.g. that might be logging the timing of an event that happened during the main loop cycle, like a GPS\nreading)."),(0,i.kt)("h3",{id:"field-encoders"},"Field encoders"),(0,i.kt)("p",null,"The field encoder's job is to use fewer bits to represent values which are closer to zero than for values that are\nfurther from zero. Blackbox supports a range of different encoders, which should be chosen on a per-field basis in order\nto minimize the encoded data size. The choice of best encoder is based on the probability distribution of the values\nwhich are to be encoded. For example, if a field is almost always zero, then an encoding should be chosen for it which\ncan encode that case into a very small number of bits, such as one. Conversely, if a field is normally 8-16 bits large,\nit would be wasteful to use an encoder which provided a special short encoded representation for zero values, because\nthis will increase the encoded length of larger values."),(0,i.kt)("p",null,"These encoders are presently available:"),(0,i.kt)("h4",{id:"unsigned-variable-byte-1"},"Unsigned variable byte (1)"),(0,i.kt)("p",null,"This is the most straightforward encoding. This encoding uses the lower 7 bits of an encoded byte to store the lower 7\nbits of the field's value. The high bit of that encoded byte is set to one if more than 7 bits are required to store the\nvalue. If the value did exceed 7 bits, the lower 7 bits of the value (which were written to the log) are removed from\nthe value (by right shift), and the encoding process begins again with the new value."),(0,i.kt)("p",null,"This can be represented by the following algorithm:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'while (value > 127) {\n    writeByte((uint8_t) (value | 0x80)); // Set the high bit to mean "more bytes follow"\n    value >>= 7;\n}\nwriteByte(value);\n')),(0,i.kt)("p",null,"Here are some example values encoded using variable-byte encoding:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Input value"),(0,i.kt)("th",{parentName:"tr",align:null},"Output encoding"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0x01")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"42"),(0,i.kt)("td",{parentName:"tr",align:null},"0x2A")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"127"),(0,i.kt)("td",{parentName:"tr",align:null},"0x7F")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"128"),(0,i.kt)("td",{parentName:"tr",align:null},"0x80 0x01")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"129"),(0,i.kt)("td",{parentName:"tr",align:null},"0x81 0x01")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"23456"),(0,i.kt)("td",{parentName:"tr",align:null},"0xA0 0xB7 0x01")))),(0,i.kt)("h4",{id:"signed-variable-byte-0"},"Signed variable byte (0)"),(0,i.kt)("p",null,'This encoding applies a pre-processing step to fold negative values into positive ones, then the resulting unsigned\nnumber is encoded using unsigned variable byte encoding. The folding is accomplished by "ZigZag" encoding, which is\nrepresented by:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"unsigned32 = (signed32 << 1) ^ (signed32 >> 31)\n")),(0,i.kt)("p",null,"ZigZag encoding is preferred against simply casting the signed integer to unsigned, because casting would cause small\nnegative quantities to appear to be very large unsigned integers, causing the encoded length to be similarly large.\nZigZag encoding ensures that values near zero are still near zero after encoding."),(0,i.kt)("p",null,"Here are some example integers encoded using ZigZag encoding:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Input value"),(0,i.kt)("th",{parentName:"tr",align:null},"ZigZag encoding"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"-1"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"-2"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2147483647"),(0,i.kt)("td",{parentName:"tr",align:null},"4294967294")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"-2147483648"),(0,i.kt)("td",{parentName:"tr",align:null},"4294967295")))),(0,i.kt)("h4",{id:"neg-14-bit-3"},"Neg 14-bit (3)"),(0,i.kt)("p",null,"The value is negated, treated as an unsigned 14 bit integer, then encoded using unsigned variable byte encoding. This\nbizarre encoding is used in Cleanflight for battery pack voltages. This is because battery voltages are measured using a\n14-bit ADC, with a predictor which is set to the battery voltage during arming, which is expected to be higher than any\nvoltage experienced during flight. After the predictor is subtracted, the battery voltage will almost certainly be below\nzero."),(0,i.kt)("p",null,"This results in small encoded values when the voltage is closely below the initial one, at the expense of very large\nencoded values if the voltage rises higher than the initial one."),(0,i.kt)("h4",{id:"elias-delta-unsigned-32-bit-4"},"Elias delta unsigned 32-bit (4)"),(0,i.kt)("p",null,"Because this encoding produces a bitstream, this is the only encoding for which the encoded value might not be a whole\nnumber of bytes. If the bitstream isn't aligned on a byte boundary by the time the next non-Elias Delta field arrives,\nor the end of the frame is reached, the final byte is padded with zeros byte-align the stream. This encoding requires\nmore CPU time than the other encodings because of the bit juggling involved in writing the bitstream."),(0,i.kt)("p",null,"When this encoder is chosen to encode all of the values in Cleanflight interframes, it saves about 10% bandwidth\ncompared to using a mixture of the other encodings, but uses too much CPU time to be practical."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Elias_delta_coding"},"The basic encoding algorithm is defined on Wikipedia"),". Given these\nutility functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"/* Write `bitCount` bits from the least-significant end of the `bits` integer to the bitstream. The most-significant bit\n * will be written first\n */\nvoid writeBits(uint32_t bits, unsigned int bitCount);\n\n/* Returns the number of bits needed to hold the top-most 1-bit of the integer 'i'. 'i' must not be zero. */\nunsigned int numBitsToStoreInteger(uint32_t i);\n")),(0,i.kt)("p",null,"This is our reference implementation of Elias Delta:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Value must be more than zero\nvoid writeU32EliasDeltaInternal(uint32_t value)\n{\n    unsigned int valueLen, lengthOfValueLen;\n\n    valueLen = numBitsToStoreInteger(value);\n    lengthOfValueLen = numBitsToStoreInteger(valueLen);\n\n    // Use unary to encode the number of bits we'll need to write the length of the value\n    writeBits(0, lengthOfValueLen - 1);\n\n    // Now write the length of the value\n    writeBits(valueLen, lengthOfValueLen);\n\n    // Having now encoded the position of the top bit of value, write its remaining bits\n    writeBits(value, valueLen - 1);\n}\n")),(0,i.kt)("p",null,"To this we add a wrapper which allows encoding both the value zero and MAXINT:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'void writeU32EliasDelta(uint32_t value)\n{\n    /* We can\'t encode value==0, so we need to add 1 to the value before encoding\n     *\n     * That would make it impossible to encode MAXINT, so use 0xFFFFFFFF as an escape\n     * code with an additional bit to choose between MAXINT-1 or MAXINT.\n     */\n    if (value >= 0xFFFFFFFE) {\n        // Write the escape code\n        writeU32EliasDeltaInternal(0xFFFFFFFF);\n        // Add a one bit after the escape code if we wanted "MAXINT", or a zero if we wanted "MAXINT - 1"\n        writeBits(value - 0xFFFFFFFE, 1);\n    } else {\n        writeU32EliasDeltaInternal(value + 1);\n    }\n}\n')),(0,i.kt)("p",null,"Here are some reference encoded bit patterns produced by writeU32EliasDelta:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Input value"),(0,i.kt)("th",{parentName:"tr",align:null},"Encoded bit string"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"0100")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"0101")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"01100")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"01101")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"5"),(0,i.kt)("td",{parentName:"tr",align:null},"01110")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"6"),(0,i.kt)("td",{parentName:"tr",align:null},"01111")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"7"),(0,i.kt)("td",{parentName:"tr",align:null},"00100000")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"8"),(0,i.kt)("td",{parentName:"tr",align:null},"00100001")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"9"),(0,i.kt)("td",{parentName:"tr",align:null},"00100010")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"10"),(0,i.kt)("td",{parentName:"tr",align:null},"00100011")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"11"),(0,i.kt)("td",{parentName:"tr",align:null},"00100100")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"12"),(0,i.kt)("td",{parentName:"tr",align:null},"00100101")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"13"),(0,i.kt)("td",{parentName:"tr",align:null},"00100110")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"14"),(0,i.kt)("td",{parentName:"tr",align:null},"00100111")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"15"),(0,i.kt)("td",{parentName:"tr",align:null},"001010000")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"225"),(0,i.kt)("td",{parentName:"tr",align:null},"00010001100010")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4294967292"),(0,i.kt)("td",{parentName:"tr",align:null},"000001000001111111111111111111111111111101")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4294967293"),(0,i.kt)("td",{parentName:"tr",align:null},"000001000001111111111111111111111111111110")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4294967294"),(0,i.kt)("td",{parentName:"tr",align:null},"0000010000011111111111111111111111111111110")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4294967295"),(0,i.kt)("td",{parentName:"tr",align:null},"0000010000011111111111111111111111111111111")))),(0,i.kt)("p",null,"Note that the very common value of zero encodes to a single bit, medium-sized values like 225 encode to 14 bits (an\noverhead of 4 bits over writing a plain 8 bit value), and typical 32-bit values like 4294967293 encode into 42 bits, an\noverhead of 10 bits."),(0,i.kt)("h4",{id:"elias-delta-signed-32-bit-5"},"Elias delta signed 32-bit (5)"),(0,i.kt)("p",null,"The value is first converted to unsigned using ZigZag encoding, then unsigned Elias-delta encoding is applied."),(0,i.kt)("h4",{id:"tag8_8svb-6"},"TAG8_8SVB (6)"),(0,i.kt)("p",null,"First, an 8-bit (one byte) header is written. This header has its bits set to zero when the corresponding field (from a\nmaximum of 8 fields) is set to zero, otherwise the bit is set to one. The least-signficant bit in the header corresponds\nto the first field to be written. This header is followed by the values of only the fields which are non-zero, written\nusing signed variable byte encoding."),(0,i.kt)("p",null,"This encoding is preferred for groups of fields in interframes which are infrequently updated by the flight controller.\nThis will mean that their predictions are usually perfect, and so the value to be encoded for each field will normally\nbe zero. This is common for values like RC inputs and barometer readings, which are updated in only a fraction of main\nloop iterations."),(0,i.kt)("p",null,"For example, given these field values to encode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0, 0, 4, 0, 8\n")),(0,i.kt)("p",null,"This would be encoded:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0b00010100, 0x04, 0x08\n")),(0,i.kt)("h4",{id:"tag2_3s32-7"},"TAG2_3S32 (7)"),(0,i.kt)("p",null,"A 2-bit header is written, followed by 3 signed field values of up to 32 bits each. The header value is based on the\nmaximum size in bits of the three values to be encoded as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Header value"),(0,i.kt)("th",{parentName:"tr",align:null},"Maximum field value size"),(0,i.kt)("th",{parentName:"tr",align:null},"Field range"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-2...1]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-8...7]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"6 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-32...31]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"Up to 32 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-2147483648...2147483647]")))),(0,i.kt)("p",null,"If any of the three values requires more than 6 bits to encode, a second, 6-bit header value is written in the lower\nbits of the initial header byte. This second header has 2 bits for each of the encoded values which represents how many\nbytes are required to encode that value. The least-significant bits of the header represent the first field which is\nencoded. The values for each possibility are as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Header value"),(0,i.kt)("th",{parentName:"tr",align:null},"Field size"),(0,i.kt)("th",{parentName:"tr",align:null},"Field range"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"1 byte"),(0,i.kt)("td",{parentName:"tr",align:null},"[-127...128]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes"),(0,i.kt)("td",{parentName:"tr",align:null},"[-32768...32767]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"3 bytes"),(0,i.kt)("td",{parentName:"tr",align:null},"[-8388608...8388607]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes"),(0,i.kt)("td",{parentName:"tr",align:null},"[-2147483648...2147483647]")))),(0,i.kt)("p",null,"This header is followed by the actual field values in order, written least-significant byte first, using the byte\nlengths specified in the header."),(0,i.kt)("p",null,'So bringing it all together, these encoded bit patterns are possible, where "0" and "1" mean bits fixed to be those\nvalues, "A", "B", and "C" represent the first, second and third fields, and "s" represents the bits of the secondary\nheader in the case that any field is larger than 6 bits:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'00AA BBCC,\n0100 AAAA BBBB CCCC\n10AA AAAA 00BB BBBB 00CC CCCC\n11ss ssss (followed by fields of byte lengths specified in the "s" header)\n')),(0,i.kt)("p",null,"This encoding is useful for fields like 3-axis gyroscopes, which are frequently small and typically have similar\nmagnitudes."),(0,i.kt)("h4",{id:"tag8_4s16-8"},"TAG8_4S16 (8)"),(0,i.kt)("p",null,"An 8-bit header is written, followed by 4 signed field values of up to 16 bits each. The 8-bit header value has 2 bits\nfor each of the encoded fields (the least-significant bits represent the first field) which represent the\nnumber of bits required to encode that field as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Header value"),(0,i.kt)("th",{parentName:"tr",align:null},"Field value size"),(0,i.kt)("th",{parentName:"tr",align:null},"Field range"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"0 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[0...0]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-8...7]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"8 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-128...127]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"16 bits"),(0,i.kt)("td",{parentName:"tr",align:null},"[-32768...32767]")))),(0,i.kt)("p",null,"This header is followed by the actual field values in order, written as if the output stream was a bit-stream, with the\nmost-significant bit of the first field ending up in the most-significant bits of the first written byte. If the number\nof nibbles written is odd, the final byte has its least-significant nibble set to zero."),(0,i.kt)("p",null,"For example, given these field values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"13, 0, 4, 2\n")),(0,i.kt)("p",null,"Choosing from the allowable field value sizes, they may be encoded using this many bits each:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"8, 0, 4, 4\n")),(0,i.kt)("p",null,"The corresponding header values for these lengths would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2, 0, 1, 1\n")),(0,i.kt)("p",null,"So the header and fields would be encoded together as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0b01010010, 0x0D, 0x42\n")),(0,i.kt)("h4",{id:"null-9"},"NULL (9)"),(0,i.kt)("p",null,'This encoding does not write any bytes to the file. It is used when the predictor will always perfectly predict the\nvalue of the field, so the remainder is always zero. In practice this is only used for the "loopIteration" field in\ninterframes, which is always perfectly predictable based on the logged frame\'s position in the sequence of frames and\nthe "P interval" setting from the header.'),(0,i.kt)("h2",{id:"log-file-structure"},"Log file structure"),(0,i.kt)("p",null,'A logging session begins with a log start marker, then a header section which describes the format of the log, then the\nlog payload data, and finally an optional "log end" event ("E" frame).'),(0,i.kt)("p",null,"A single log file can be comprised of one or more logging sessions. Each session may be preceded and followed by any\namount of non-Blackbox data. This data is ignored by the Blackbox log decoding tools. This allows for the logging device\nto be alternately used by the Blackbox and some other system (such as MSP) without requiring the ability to begin a\nseparate log file for each separate activity."),(0,i.kt)("h3",{id:"log-start-marker"},"Log start marker"),(0,i.kt)("p",null,'The log start marker is "H Product:Blackbox flight data recorder by Nicholas Sherlock\\n". This marker is\nused to discover the beginning of the flight log if the log begins partway through a file. Because it is such a long\nstring, it is not expected to occur by accident in any sequence of random bytes from other log device users.'),(0,i.kt)("h3",{id:"log-header"},"Log header"),(0,i.kt)("p",null,"The header is comprised of a sequence of lines of plain ASCII text. Each header line has the format ",(0,i.kt)("inlineCode",{parentName:"p"},"H fieldname:value"),"\nand ends with a '\\n'. The overall header does not have a terminator to separate it from the log payload\n(the header implicitly ends when a line does not begin with an 'H' character)."),(0,i.kt)("p",null,"The header can contain some of these fields:"),(0,i.kt)("h4",{id:"data-version-required"},"Data version (required)"),(0,i.kt)("p",null,"When the interpretation of the Blackbox header changes due to Blackbox specification updates, the log version is\nincremented to allow backwards-compatibility in the decoder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Data version:2\n")),(0,i.kt)("h4",{id:"logging-interval"},"Logging interval"),(0,i.kt)("p",null,"Not every main loop iteration needs to result in a Blackbox logging iteration. When a loop iteration is not logged,\nBlackbox is not called, no state is read from the flight controller, and nothing is written to the log. Two header lines\nare included to note which main loop iterations will be logged:"),(0,i.kt)("h5",{id:"i-interval"},"I interval"),(0,i.kt)("p",null,'This header notes which of the main loop iterations will record an "I" intraframe to the log. If main loop iterations\nwith indexes divisible by 32 will be logged as "I" frames, the header will be:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H I interval: 32\n")),(0,i.kt)("p",null,"The first main loop iteration seen by Blackbox will be numbered with index 0, so the first main loop iteration will\nalways be logged as an intraframe."),(0,i.kt)("h5",{id:"p-interval"},"P interval"),(0,i.kt)("p",null,'Not every "P" interframe needs to be logged. Blackbox will log a portion of iterations in order to bring the total\nportion of logged main frames to a user-chosen fraction. This fraction is called the logging rate. The smallest possible\nlogging rate is ',(0,i.kt)("inlineCode",{parentName:"p"},"(1/I interval)"),' which corresponds to logging only "I" frames at the "I" interval and discarding all\nother loop iterations. The maximum logging rate is ',(0,i.kt)("inlineCode",{parentName:"p"},"1/1"),', where every main loop iteration that is not an "I" frame is\nlogged as a "P" frame. The header records the logging rate fraction in ',(0,i.kt)("inlineCode",{parentName:"p"},"numerator/denominator")," format like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H P interval:1/2\n")),(0,i.kt)("p",null,"The logging fraction given by ",(0,i.kt)("inlineCode",{parentName:"p"},"num/denom")," should be simplified (i.e. rather than 2/6, a logging rate of 1/3 should\nbe used)."),(0,i.kt)("p",null,"Given a logging rate of ",(0,i.kt)("inlineCode",{parentName:"p"},"num/denom")," and an I-frame interval of ",(0,i.kt)("inlineCode",{parentName:"p"},"I_INTERVAL"),", the frame type to log for an iteration\nof index ",(0,i.kt)("inlineCode",{parentName:"p"},"iteration")," is given by:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if (iteration % I_INTERVAL == 0)\n    return 'I';\n\nif ((iteration % I_INTERVAL + num - 1) % denom < num)\n    return 'P';\n\nreturn '.'; // i.e. don't log this iteration\n")),(0,i.kt)("p",null,"For an I-interval of 32, these are the resulting logging patterns at some different P logging rates."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Logging rate"),(0,i.kt)("th",{parentName:"tr",align:null},"Main frame pattern"),(0,i.kt)("th",{parentName:"tr",align:null},"Actual portion logged"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1 / 32"),(0,i.kt)("td",{parentName:"tr",align:null},"I...............................I...............................I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.03")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1 / 6"),(0,i.kt)("td",{parentName:"tr",align:null},"I.....P.....P.....P.....P.....P.I.....P.....P.....P.....P.....P.I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.19")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1 / 3"),(0,i.kt)("td",{parentName:"tr",align:null},"I..P..P..P..P..P..P..P..P..P..P.I..P..P..P..P..P..P..P..P..P..P.I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.34")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1 / 2"),(0,i.kt)("td",{parentName:"tr",align:null},"I.P.P.P.P.P.P.P.P.P.P.P.P.P.P.P.I.P.P.P.P.P.P.P.P.P.P.P.P.P.P.P.I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.50")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2 / 3"),(0,i.kt)("td",{parentName:"tr",align:null},"I.PP.PP.PP.PP.PP.PP.PP.PP.PP.PP.I.PP.PP.PP.PP.PP.PP.PP.PP.PP.PP.I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.66")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"5 / 6"),(0,i.kt)("td",{parentName:"tr",align:null},"I.PPPPP.PPPPP.PPPPP.PPPPP.PPPPP.I.PPPPP.PPPPP.PPPPP.PPPPP.PPPPP.I"),(0,i.kt)("td",{parentName:"tr",align:null},"0.81")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1 / 1"),(0,i.kt)("td",{parentName:"tr",align:null},"IPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPIPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPI"),(0,i.kt)("td",{parentName:"tr",align:null},"1.00")))),(0,i.kt)("h4",{id:"firmware-type-optional"},"Firmware type (optional)"),(0,i.kt)("p",null,"Because Blackbox records the internal flight controller state, the interpretation of the logged data will depend\non knowing which flight controller recorded it. To accomodate this, the name of the flight controller should be recorded:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Firmware type:Cleanflight\n")),(0,i.kt)("p",null,"More details should be included to help narrow down the precise flight-controller version (but these are not required):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Firmware revision:c49bd40\nH Firmware date:Aug 28 2015 16:49:11\n")),(0,i.kt)("h4",{id:"field-x-name-required"},"Field X name (required)"),(0,i.kt)("p",null,"This header is a comma-separated list of the names for the fields in the 'X' frame type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Field I name:loopIteration,time,axisP[0],axisP[1]...\n")),(0,i.kt)("p",null,"The decoder assumes that the fields in the 'P' frame type will all have the same names as those in the 'I' frame, so\na \"Field P name\" header does not need to be supplied."),(0,i.kt)("h4",{id:"field-x-signed-optional"},"Field X signed (optional)"),(0,i.kt)("p",null,"This is a comma-separated list of integers which are set to '1' when their corresponding field's value should be\ninterpreted as signed after decoding, or '0' otherwise:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Field I signed:0,0,1,1...\n")),(0,i.kt)("h4",{id:"field-x-predictor-required"},"Field X predictor (required)"),(0,i.kt)("p",null,"This is a comma-separated list of integers which specify the predictors for each field in the specified frame type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Field I predictor:0,0,0,0...\n")),(0,i.kt)("h4",{id:"field-x-encoding-required"},"Field X encoding (required)"),(0,i.kt)("p",null,"This is a comma-separated list of integers which specify the encoding used for each field in the specified frame type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H Field X encoding:1,1,0,0...\n")),(0,i.kt)("h4",{id:"vbatref"},"vbatref"),(0,i.kt)("p",null,"This header provides the reference voltage that will be used by predictor #9."),(0,i.kt)("h4",{id:"minthrottle"},"minthrottle"),(0,i.kt)("p",null,"This header provides the minimum value sent by Cleanflight to the ESCs when armed, it is used by predictor #4."),(0,i.kt)("h4",{id:"additional-headers"},"Additional headers"),(0,i.kt)("p",null,"The decoder ignores headers that it does not understand, so you can freely add any headers that you require in order to\nproperly interpret the meaning of the logged values."),(0,i.kt)("p",null,'For example, to create a graphical displays of RC sticks and motor percentages, the Blackbox rendering tool requires\nthe additional headers "rcRate" and "maxthrottle". In order to convert raw gyroscope, accelerometer and voltage readings\ninto real-world units, the Blackbox decoder requires the calibration constants "gyro.scale", "acc_1G" and "vbatscale".\nThese headers might look like:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"H rcRate:100\nH maxthrottle:1980\nH gyro.scale:0x3d79c190\nH acc_1G:4096\nH vbatscale:110\n")),(0,i.kt)("h3",{id:"log-payload"},"Log payload"),(0,i.kt)("p",null,"The log payload is a concatenated sequence of logged frames. Each frame type which is present in the log payload must\nhave been previously described in the log header (with Frame X name, etc. headers). Each frame begins with a single\ncapital letter to specify the type of frame (I, P, etc), which is immediately followed by the frame's field data. There\nis no frame length field, checksum, or trailer."),(0,i.kt)("p",null,"The field data is encoded by taking an array of raw field data, computing the predictor for each field, subtrating this\npredictor from the field, then applying the field encoders to each field in sequence to serialize them to the log."),(0,i.kt)("p",null,"For example, imagine that we are encoding three fields in an intraframe, are using zero-predictors for each field (#0),\nand are encoding the values using the unsigned variable byte encoding (#1). For these field values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1, 2, 3\n")),(0,i.kt)("p",null,"We would encode a frame:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"'I', 0x01, 0x02, 0x03\n")),(0,i.kt)("p",null,"Imagine that we are encoding an array of motor commands in an interframe. We will use the previous motor commands as a\npredictor, and encode the resulting values using signed variable byte encoding. The motor command values seen in the\nprevious logged iteration were:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1430, 1500, 1470, 1490\n")),(0,i.kt)("p",null,"And the motor commands to be logged in this iteration are:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1635, 1501, 1469, 1532\n")),(0,i.kt)("p",null,"After subtracting the predictors for each field, we will be left with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"205, 1, -1, 42\n")),(0,i.kt)("p",null,"We will apply ZigZag encoding to each field, which will give us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"410, 2, 1, 84\n")),(0,i.kt)("p",null,"We will use unsigned variable byte encoding to write the resulting values to the log, which will give us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"'P', 0x9A, 0x03, 0x02, 0x01, 0x54\n")),(0,i.kt)("h3",{id:"log-end-marker"},"Log end marker"),(0,i.kt)("p",null,'The log end marker is an optional Event ("E") frame of type 0xFF whose payload is the string "End of log\\0". The\npayload ensures that random data does not look like an end-of-log marker by chance. This event signals the tidy ending\nof the log. All following bytes until the next log-begin marker (or end of file) should be ignored by the log\ndecoder.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"'E', 0xFF, \"End of log\0\", 0x00\n")),(0,i.kt)("h2",{id:"log-validation"},"Log validation"),(0,i.kt)("p",null,"Any damage experienced to the log during recording is overwhelmingly due to subsequences of bytes being dropped by the\nlogging device due to overflowing buffers. Accordingly, Blackbox logs do not bother to include any checksums (bytes are\nnot expected to be damaged by the logging device without changing the length of the message). Because of the tight\nbandwidth requirements of logging, neither a frame length field nor frame trailer is recorded that would allow for the\ndetection of missing bytes."),(0,i.kt)("p",null,"Instead, the decoder uses a heuristic in order to detect damaged frames. The decoder reads an entire frame from the log\n(using the decoder for each field which is the counterpart of the encoder specified in the header), then it checks to\nsee if the byte immediately following the frame, which should be the beginning of a next frame, is a recognized\nframe-type byte (e.g. 'I', 'P', 'E', etc). If that following byte represents a valid frame type, it is assumed that the\ndecoded frame was the correct length (so was unlikely to have had random ranges of bytes removed from it, which would\nhave likely altered the frame length). Otherwise, the frame is rejected, and a valid frame-type byte is looked for\nimmediately after the frame-start byte of the frame that was rejected. A rejected frame causes all subsequent\ninterframes to be rejected as well, up until the next intraframe."),(0,i.kt)("p",null,'A frame is also rejected if the "loopIteration" or "time" fields have made unreasonable leaps forward, or moved at\nall backwards. This suffices to detect almost all log corruption.'))}g.isMDXComponent=!0}}]);